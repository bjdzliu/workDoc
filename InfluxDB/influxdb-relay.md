# influxdb-relay

influxdb官方在闭源其集群组件时开源一个名为Influx-Relay的高可用套件
```
        ┌─────────────────┐                 
        │writes & queries │                 
        └─────────────────┘                 
                 │                          
                 ▼                          
         ┌───────────────┐                  
         │               │                  
┌────────│ Load Balancer │─────────┐        
│        │               │         │        
│        └──────┬─┬──────┘         │        
│               │ │                │        
│               │ │                │        
│        ┌──────┘ └────────┐       │        
│        │ ┌─────────────┐ │       │┌──────┐
│        │ │/write or UDP│ │       ││/query│
│        ▼ └─────────────┘ ▼       │└──────┘
│  ┌──────────┐      ┌──────────┐  │        
│  │ InfluxDB │      │ InfluxDB │  │        
│  │ Relay    │      │ Relay    │  │        
│  └──┬────┬──┘      └────┬──┬──┘  │        
│     │    |              |  │     │        
│     |  ┌─┼──────────────┘  |     │        
│     │  │ └──────────────┐  │     │        
│     ▼  ▼                ▼  ▼     │        
│  ┌──────────┐      ┌──────────┐  │        
│  │          │      │          │  │        
└─▶│ InfluxDB │      │ InfluxDB │◀─┘        
   │          │      │          │           
   └──────────┘      └──────────┘           
 ```

## 入门介绍

influxdb-relay由三部分构成:
- 一个负载均衡器
- 多个influxdb-relay实例(多个指两个以上)
- 多个influxdb实例构成(多个指两个以上).

负载均衡器会把UDP和HTTP的POST请求分发到influxdb-relay上,而将/query的get请求分发到influxdb server.



influxdb-relay实例会持续监听HTTP或者UDP的写请求.

如果写请求是通过http发出的,当集群中有任意一台influxdb server返回成功信息时或者状态码为4xx时,会立即将结果返回给客户端.

如果状态码是5xx,而且是所有的influxdb server都给出了5xx,那么这个结果也会立即返回给客户端.
但是如果只是部分服务器返回5xx,那么relay将会忽略这个5xx错误.


所以在这种机制下,如果某个relay或者influxdb出现了异常,集群不会尝试做恢复操作,这个可能需要人工进行干预.

## 缓冲:
relay提供一个队列用于缓冲失败请求,用于减少因为短暂的或者周期性网络故障导致的失败请求的数量

*要注意的是,这个缓冲机制不能用于长时间故障的情况,因为所有的缓冲数据都存在RAM中*


缓冲有如下配置选项:

- buffer-size-mb : 缓冲队列的大小
- max-batch-kb : 提交聚合数据的最大值
- max-delay-interval : 最大延迟间隔.此时间隔为500ms,每失败一次间隔加倍.

如果缓冲区满了,此后的请求会被直接忽略并记下日志.进入队列的请求会不断重试直到成功为止

重试的数据被序列化后会发送到单个后端.当重试的数据小于max-batch-kb时,relay会尽量对数据进行聚合做批量处理.如果请求重试成功了,会立即开始处理队列中的下个请求.

如果relay在后端服务宕机期间

// todo: 

## 恢复:
InfluxDB根据时间在磁盘上组织逻辑数据块, 我们可以根据这一特性对服务器做"热恢复".

这些碎片代表的时间长度一般是1h,1day 或者7days, 取决于要保留的时间.接下来我们的例子中都假设保留时间为1天.

现在我们假设集群中的一个InfluxDB服务在2016-3-10号宕机一个小时,再经过一天的运行后,influxdb正在组织2016-03-11的数据,而此时存放2016-3-10号的那个文件已经变为冷存储了.我们可以通过以下步骤尝试恢复.

1. 负载均衡器不要将query的任务流量导入到宕机过的机器上(这一步必须在检测到宕机后就应该立即处理了,防止出现查询不一致的情况)
2. 从正常运行的server上备份一份2016-03-10的数据
3. 将这份数据从正常的server转移到已经宕机的机器上.
4. 负载均衡器恢复query的任务流量到宕机的机器上.

*注意在这个过程中宕机过的那台机器还是要执行写操作的任务*

## 分片:

待补充

## 注意事项:

虽然influxdb-relay提供了一定程度上的高可用能力,但有几种情况需要注意下:

- 查询任务不经过relay的,而且包括了修改数据库模型这一系列的操作.所以在使用relay写入数据之前,数据库的模型必须已经定义好.

- 连续的查询时只会将数据先写在本地上,如果服务器宕机了,在数据恢复过来后要将查询结果响应给查询者.

- 数据覆写这一情况是潜在存在的.举个栗子,有serverA,serverB两个服务实例,如果B宕了,数据X(假设其值为v)在B恢复之前要执行写入,

// todo